# 컴퓨터 내부의 언어 체계

사람: 자연어 => 문자 (ㄱ,ㄴ,ㄷ)<br>
컴퓨터: 문자 => 비트 (0, 1)

- 비트: binary + digit

  -> 적은 비용으로 편리하게 기호를 담을 수 있음

논리 연산: 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작

## Boolean 대수

- 결합, 교환 분배법칙 성립
- 연산자 (NOT, AND, OR, XOR)

<br>

| 연산자 |                       설명                       |
| :----: | :----------------------------------------------: |
|  NOT   |    1개 비트에서 사용 / 참 -> 거짓, 거짓 -> 참    |
|  AND   | 모든 비트 참 -> 참, 하나의 비트라도 거짓 -> 거짓 |
|   OR   | 하나의 비트라도 참 -> 참, 모든 비트 거짓 -> 거짓 |
|  XOR   | 두 값이 다른 경우 -> 참, 두 값이 같은 경우 거짓  |

<br>

## 드모르간의 법칙

a AND b = NOT (NOT a OR NOT b)<br>
NOT을 사용하면 AND연산을 OR로 대신할 수 있다.

<br>

## 정수를 비트로 표현하는 방법

비트는 2진시룰 사용

가장 작은 유효 비트(Lesat Siginificant Bit, LSB): 가장 오른쪽 / 2진수의 값이 가장 작게 변경<br>
가장 큰 유효 비트(Most Siginificant Bit, MSB): 가장 왼쪽 / 2진수의 값이 가장 크게 변경

## 2진수 덧셈

```python
1
5
-
6

# LSB부터 덧셈
001
101
---
110
```

<br>

|  A  |  B  | A AND B | A + B | A XOR B |  A  |  B  |
| :-: | :-: | :-----: | :---: | :-----: | :-: | :-: |
|  0  |  0  |    0    |  00   |    0    |  0  |  0  |
|  0  |  1  |    0    |  01   |    1    |  0  |  1  |
|  1  |  0  |    0    |  10   |    1    |  1  |  0  |
|  1  |  1  |    1    |  11   |    0    |  1  |  1  |

<br>

AND: 두 비트의 올림 값 <br>
XOR: 두 비트를 더한 값

Q: 사용할 비트의 개수로 펴한할 범위를 벗어나면 어떻게 되나?<br>
A: Overflow 발생 (= MSB에서 올림이 발생했따는 의미)

```python
# 4비트 덧셈
1001
1000
----
10001 => 0001 (4비트이므로)
```

나중에 배울 조건코드(or 상태코드) 레지스트에서 확인 가능<br>
(이 중 오버플로 비트가 있고 MSB에서 발생한 올림값이 들어감)

## 음수 표현

### 부호와 크기

음수와 양수를 구별하기 위해 부호를 사용한다.<br>
MSB를 부호로 사용하기로 결정했다.<br>
양부호(+): 0<br>
음부호(-): 1<br>

부호와 크기 포현법 (사용 x)<br>
: 0부터의 거리 (절댓값)

| 부호 | 2²  | 2¹  | 2⁰  | 10진수 |
| :--: | :-: | :-: | :-: | :----: |
|  0   |  1  |  1  |  1  |   +7   |
|  0   |  1  |  1  |  0  |   +6   |
|  0   |  1  |  0  |  1  |   +5   |
|  0   |  1  |  0  |  0  |   +4   |
|  0   |  0  |  1  |  1  |   +3   |
|  0   |  0  |  1  |  0  |   +2   |
|  0   |  0  |  0  |  1  |   +1   |
|  0   |  0  |  0  |  0  |   +0   |
|  1   |  0  |  0  |  0  |   -0   |
|  1   |  0  |  0  |  1  |   -1   |
|  1   |  0  |  1  |  0  |   -2   |
|  1   |  0  |  1  |  1  |   -3   |
|  1   |  1  |  0  |  0  |   -4   |
|  1   |  1  |  0  |  1  |   -5   |
|  1   |  1  |  1  |  0  |   -6   |
|  1   |  1  |  1  |  1  |   -7   |

#### 문제점

1. 0을 표현하는 방식 2가지<br>
   0000(+0), 1000(-0)
2. XOR과 AND를 통한 덧셈 불가

   ```python
   0001 |  1
   1001 | -1
   ----------
   1010 | -2 (실제로는 0이 나와야함)
   ```

### 1의 보수 (one's complement)

음수를 표현하는 또 다른 방식은 양수의 모든 비트를 뒤집는 것<br>
NOT 연산을 이용하여 보수를 얻을 수 있음

| 부호 | 2²  | 2¹  | 2⁰  | 10진수 |
| :--: | :-: | :-: | :-: | :----: |
|  0   |  1  |  1  |  1  |   +7   |
|  0   |  1  |  1  |  0  |   +6   |
|  0   |  1  |  0  |  1  |   +5   |
|  0   |  1  |  0  |  0  |   +4   |
|  0   |  0  |  1  |  1  |   +3   |
|  0   |  0  |  1  |  0  |   +2   |
|  0   |  0  |  0  |  1  |   +1   |
|  0   |  0  |  0  |  0  |   +0   |
|  1   |  1  |  1  |  1  |   -0   |
|  1   |  1  |  1  |  0  |   -1   |
|  1   |  1  |  0  |  1  |   -2   |
|  1   |  1  |  0  |  0  |   -3   |
|  1   |  0  |  1  |  1  |   -4   |
|  1   |  0  |  1  |  0  |   -5   |
|  1   |  0  |  0  |  1  |   -6   |
|  1   |  0  |  0  |  0  |   -7   |

#### 문제점

1. 0을 표현하는 방식 2가지<br>
   0000(+0), 1111(-0)
2. 덧셈이 다소 복잡해짐 (순환 올림, 하드웨어를 추가로 구성해야 함)<br>
   MSB에서 올림이 발생한 경우 LSB로 올림을 전달해야함

   ```python
   0010|+2
   1110|-1
   -------
   10000|+1 (순환올림) => 0001| +1
   ```

### 2의 보수

어떤 수의 비트를 뒤집고 1을 추가<br>
MSB에서 올림이 발생하면 버림<br>
(+1에 더했을 때 0이 나오는 비트 패턴을 찾고 이 패턴을 -1로 지정)

| 부호 | 2²  | 2¹  | 2⁰  | 10진수 |
| :--: | :-: | :-: | :-: | :----: |
|  0   |  1  |  1  |  1  |   +7   |
|  0   |  1  |  1  |  0  |   +6   |
|  0   |  1  |  0  |  1  |   +5   |
|  0   |  1  |  0  |  0  |   +4   |
|  0   |  0  |  1  |  1  |   +3   |
|  0   |  0  |  1  |  0  |   +2   |
|  0   |  0  |  0  |  1  |   +1   |
|  0   |  0  |  0  |  0  |   0    |
|  1   |  1  |  1  |  1  |   -1   |
|  1   |  1  |  1  |  0  |   -2   |
|  1   |  1  |  0  |  1  |   -3   |
|  1   |  1  |  0  |  0  |   -4   |
|  1   |  0  |  1  |  1  |   -5   |
|  1   |  0  |  1  |  0  |   -6   |
|  1   |  0  |  0  |  1  |   -7   |
|  1   |  0  |  0  |  0  |   -8   |

#### 문제 해결

1. 0을 표현하는 방식 1가지<br>
   0000 (2의 보수를 적용해도 0000 -> 1111 (1의 보수) -> 0000 (+1))
2. XOR과 AND만으로 계산이 가능(추가 하드웨어 구성없이 덧셈 가능)
   ```python
   0001|1
   1111|-1
   -------
   10000|0 (MSB 올림 버림) => 0000|0
   ```
3. 추가로 -8까지 표현이 가능<br>
   1000 (-8)
