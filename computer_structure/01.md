# 컴퓨터 내부의 언어 체계

사람: 자연어 => 문자 (ㄱ,ㄴ,ㄷ)<br>
컴퓨터: 문자 => 비트 (0, 1)

- 비트: binary + digit

  -> 적은 비용으로 편리하게 기호를 담을 수 있음

논리 연산: 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작

## Boolean 대수

- 결합, 교환 분배법칙 성립
- 연산자 (NOT, AND, OR, XOR)

<br>

| 연산자 |                       설명                       |
| :----: | :----------------------------------------------: |
|  NOT   |    1개 비트에서 사용 / 참 -> 거짓, 거짓 -> 참    |
|  AND   | 모든 비트 참 -> 참, 하나의 비트라도 거짓 -> 거짓 |
|   OR   | 하나의 비트라도 참 -> 참, 모든 비트 거짓 -> 거짓 |
|  XOR   | 두 값이 다른 경우 -> 참, 두 값이 같은 경우 거짓  |

<br>

## 드모르간의 법칙

a AND b = NOT (NOT a OR NOT b)<br>
NOT을 사용하면 AND연산을 OR로 대신할 수 있다.

<br>

## 정수를 비트로 표현하는 방법

비트는 2진시룰 사용

가장 작은 유효 비트(Lesat Siginificant Bit, LSB): 가장 오른쪽 / 2진수의 값이 가장 작게 변경<br>
가장 큰 유효 비트(Most Siginificant Bit, MSB): 가장 왼쪽 / 2진수의 값이 가장 크게 변경

## 2진수 덧셈

```python
1
5
-
6

# LSB부터 덧셈
001
101
---
110
```

<br>

|  A  |  B  | A AND B | A + B | A XOR B |  A  |  B  |
| :-: | :-: | :-----: | :---: | :-----: | :-: | :-: |
|  0  |  0  |    0    |  00   |    0    |  0  |  0  |
|  0  |  1  |    0    |  01   |    1    |  0  |  1  |
|  1  |  0  |    0    |  10   |    1    |  1  |  0  |
|  1  |  1  |    1    |  11   |    0    |  1  |  1  |

<br>

AND: 두 비트의 올림 값 <br>
XOR: 두 비트를 더한 값

Q: 사용할 비트의 개수로 펴한할 범위를 벗어나면 어떻게 되나?<br>
A: Overflow 발생 (= MSB에서 올림이 발생했따는 의미)

```python
# 4비트 덧셈
1001
1000
----
10001 => 0001 (4비트이므로)
```

나중에 배울 조건코드(or 상태코드) 레지스트에서 확인 가능<br>
(이 중 오버플로 비트가 있고 MSB에서 발생한 올림값이 들어감)
